/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// linkNodesInCanvasIndex.ts
var linkNodesInCanvasIndex_exports = {};
__export(linkNodesInCanvasIndex_exports, {
  default: () => LinkNodesInCanvas
});
module.exports = __toCommonJS(linkNodesInCanvasIndex_exports);
var import_obsidian = require("obsidian");
var LinkNodesInCanvas = class extends import_obsidian.Plugin {
  async onload() {
    this.registerCustomCommands();
    this.registerCustomSuggester();
  }
  registerCustomCommands() {
    this.addCommand({
      id: "link-between-selection-nodes",
      name: "Link Between Selection Nodes",
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
          if (!checking) {
            const canvas = canvasView.canvas;
            const selection = canvas.selection;
            const fileNodes = Array.from(selection).filter((node) => (node == null ? void 0 : node.filePath) !== void 0);
            if (fileNodes.length === 0)
              return;
            const resolvedLinks = app.metadataCache.resolvedLinks;
            fileNodes.forEach((node) => {
              const allLinks = Object.keys(resolvedLinks[node.filePath]);
              for (let i = 0; i < fileNodes.length; i++) {
                if (allLinks.includes(fileNodes[i].filePath)) {
                  if (node !== fileNodes[i])
                    this.createEdge(node, fileNodes[i], canvas);
                }
              }
            });
            canvas.requestSave();
          }
          return true;
        }
      }
    });
  }
  registerCustomSuggester() {
    this.registerEditorSuggest(new NodeSuggest(this));
  }
  createEdge(node1, node2, canvas) {
    var _a;
    const random = (e) => {
      let t = [];
      for (let n = 0; n < e; n++) {
        t.push((16 * Math.random() | 0).toString(16));
      }
      return t.join("");
    };
    const edge = canvas.edges.get((_a = canvas.getData().edges.first()) == null ? void 0 : _a.id);
    if (edge) {
      const tempEdge = new edge.constructor(canvas, random(16), { side: "right", node: node1 }, { side: "left", node: node2 });
      canvas.addEdge(tempEdge);
      tempEdge.attach();
      tempEdge.render();
    } else {
      new import_obsidian.Notice("You should have at least one edge in the canvas to use this command.");
    }
  }
  createEdgeBasedOnNodes(node1, node2, canvas, side) {
    var _a;
    const random = (e) => {
      let t = [];
      for (let n = 0; n < e; n++) {
        t.push((16 * Math.random() | 0).toString(16));
      }
      return t.join("");
    };
    const edge = canvas.edges.get((_a = canvas.getData().edges.first()) == null ? void 0 : _a.id);
    if (edge) {
      let tempEdge;
      console.log(side);
      switch (side) {
        case "left":
          tempEdge = new edge.constructor(canvas, random(16), { side: "left", node: node1 }, { side: "right", node: node2 });
          break;
        case "right":
          tempEdge = new edge.constructor(canvas, random(16), { side: "right", node: node1 }, { side: "left", node: node2 });
          break;
        case "top":
          tempEdge = new edge.constructor(canvas, random(16), { side: "top", node: node1 }, { side: "bottom", node: node2 });
          break;
        case "bottom":
          tempEdge = new edge.constructor(canvas, random(16), { side: "bottom", node: node1 }, { side: "top", node: node2 });
          break;
        case "top-left":
          tempEdge = new edge.constructor(canvas, random(16), { side: "top", node: node1 }, { side: "right", node: node2 });
          break;
        case "top-right":
          tempEdge = new edge.constructor(canvas, random(16), { side: "top", node: node1 }, { side: "left", node: node2 });
          break;
        case "bottom-left":
          tempEdge = new edge.constructor(canvas, random(16), { side: "bottom", node: node1 }, { side: "right", node: node2 });
          break;
        case "bottom-right":
          tempEdge = new edge.constructor(canvas, random(16), { side: "bottom", node: node1 }, { side: "left", node: node2 });
          break;
      }
      canvas.addEdge(tempEdge);
      tempEdge.attach();
      tempEdge.render();
    } else {
      new import_obsidian.Notice("You should have at least one edge in the canvas to use this command.");
    }
  }
  onunload() {
  }
};
var NodeSuggest = class extends import_obsidian.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.nodes = [];
    this.plugin = plugin;
  }
  getNodes() {
    const canvasView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
      this.canvas = canvasView.canvas;
      const nodes = this.canvas.getData().nodes;
      return Array.from(nodes.values());
    }
    return [];
  }
  onTrigger(cursor, editor, _) {
    this.lineContents = editor.getLine(cursor.line).toLowerCase();
    const before = this.lineContents.slice(0, cursor.ch);
    const after = this.lineContents.slice(cursor.ch);
    this.end = after.indexOf("}}");
    const firstIndex = before.lastIndexOf("{{");
    const lastIndex = before.lastIndexOf("}}");
    if (!(firstIndex > lastIndex && lastIndex === -1))
      return null;
    const query = before.slice(firstIndex + 2);
    this.nodes = this.getNodes();
    this.original = Array.from(this.canvas.selection)[0];
    return {
      end: cursor,
      start: {
        ch: firstIndex,
        line: cursor.line
      },
      query
    };
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase() || "";
    this.fuzzySearch = (0, import_obsidian.prepareFuzzySearch)(query);
    const results = this.nodes.filter((node) => {
      var _a, _b;
      switch (node.type) {
        case "text":
          if (node.id === this.original.id || node.text.trim() === "")
            return false;
          return this.fuzzySearch(node.text.toLowerCase());
        case "file":
          return this.fuzzySearch(node.file.toLowerCase());
        case "group":
          if ((_a = node.label) == null ? void 0 : _a.trim())
            return this.fuzzySearch((_b = node.label) == null ? void 0 : _b.toLowerCase());
          else
            return false;
        case "link":
          if (node.url.trim().length === 0)
            return false;
          return this.fuzzySearch(node.url.toLowerCase());
      }
    });
    return results;
  }
  renderSuggestion(suggestion, el) {
    let outer;
    let iconEl;
    outer = el.createDiv({ cls: "ltn-suggester-container" });
    switch (suggestion.type) {
      case "text":
        iconEl = outer.createDiv({ cls: "ltn-suggester-icon" });
        (0, import_obsidian.setIcon)(iconEl, "sticky-note");
        outer.createDiv({ cls: "ltn-text-node" }).setText(`${suggestion.text}`);
        break;
      case "file":
        iconEl = outer.createDiv({ cls: "ltn-suggester-icon" });
        (0, import_obsidian.setIcon)(iconEl, "file-text");
        outer.createDiv({ cls: "ltn-file-node" }).setText(`${suggestion.file}`);
        break;
      case "group":
        iconEl = outer.createDiv({ cls: "ltn-suggester-icon" });
        (0, import_obsidian.setIcon)(iconEl, "box-select");
        outer.createDiv({ cls: "ltn-group-node" }).setText(`${suggestion.label}`);
        break;
      case "link":
        iconEl = outer.createDiv({ cls: "ltn-suggester-icon" });
        (0, import_obsidian.setIcon)(iconEl, "link");
        outer.createDiv({ cls: "ltn-link-node" }).setText(`${suggestion.url}`);
        break;
    }
  }
  selectSuggestion(suggestion) {
    if (this.context) {
      this.context.editor.replaceRange(``, this.context.start, this.end === 0 ? {
        ch: this.context.end.ch + 2,
        line: this.context.end.line
      } : this.context.end);
      const targetNode = this.canvas.nodes.get(suggestion.id);
      const side = this.getDirectionText(this.original.x, this.original.y, targetNode.x, targetNode.y);
      this.plugin.createEdgeBasedOnNodes(this.original, targetNode, this.canvas, side);
      this.close();
    }
  }
  getDirectionText(originalX, originalY, targetX, targetY) {
    const x = originalX - targetX;
    const y = originalY - targetY;
    const angle = Math.atan2(y, x) * 180 / Math.PI;
    const direction = Math.round((angle + 180) / 45) % 8;
    switch (direction) {
      case 0:
        return "right";
      case 1:
        return "bottom-right";
      case 2:
        return "bottom";
      case 3:
        return "bottom-left";
      case 4:
        return "left";
      case 5:
        return "top-left";
      case 6:
        return "top";
      case 7:
        return "top-right";
      default:
        return "right";
    }
  }
};
