---
created: 2023-11-15T20:55
updated: 2023-11-15T20:55
---
# 字符编码问题和二进制

## URI vs URL

## 文章：javascript 字符串进行 utf8 编码的方法（转

### [地址](https://www.cnblogs.com/zhangdaicong/p/7696738.html)

## 文章:通过javascript进行UTF-8编码的实现方法

### [地址](https://www.jb51.net/article/87418.htm)

## 二进制相关的对象

### FIleReader

- HTML5定义了FileReader作为文件API的重要成员,用于读取文件，根据W3C的定义，FileReader接口提供了读取文件的方法和包含读取结果的事件模型。
- 创建实例

	- var reader = new FileReader();

- 方法

	- 

- 事件

	- 

- 例子

	- 下面我们尝试把一个文件的内容通过字符串的方式读取出来：
	- 

### canvas

- 使用js转化画布与图片（canvas与img）

	- 1、使用JavaScript将图片拷贝进画布

		- 将图片放入画布里，使用canvas元素的drawImage方法即可：

	- 2、用JavaScript将画布保存成图片格式

		- 画布上的作品已经处理完成，可以用toDataURL将canvas数据转换成图片格式（png）：

- drawImage：向画布上绘制图像、画布或视频

	- [例子](https://www.w3school.com.cn/tiy/t.asp?f=eg_html5_canvas_drawimage3)

	- 参数

- createImageData：创建新的、空白的 ImageData 对象

	- createImageData() 方法创建新的空白 ImageData 对象。新对象的默认像素值 transparent black。

		- 对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：
		- R - 红色 (0-255)
		- G - 绿色 (0-255)
		- B - 蓝色 (0-255)
		- A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)
		- 特点

			- 因此 ，transparent black 表示 (0,0,0,0)。
			- color/alpha 以数组形式存在，并且既然数组包含了每个像素的四条信息，数组的大小是 ImageData 对象的四倍。（获得数组大小有更简单的办法，就是使用 ImageDataObject.data.length）
			- 包含 color/alpha 信息的数组存储于 ImageData 对象的 data 属性中。
			- 提示：在操作完成数组中的 color/alpha 信息之后，您可以使用 putImageData() 方法将图像数据拷贝回画布上。

	- 【语法】

		- 

	- 【参数】

		- 

- getImageData：返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据

	- 【语法】

		- 

	- 【参数】

		- 

- putImageData：把图像数据（从指定的 ImageData 对象）放回画布上

	- 【语法】

		- 

	- 【参数】

		- 

	- 【例子】

		- 

- toDataURL
- [图像处理文章：JavaScript中的图片处理与合成(四)](https://juejin.cn/post/6844903570446221319)

### ArrayBuffer/TypedArray/DataView 对象

- ArrayBuffer

	- 【定义】

		- ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。

	- 【语法】

		- // new ArrayBuffer(length)
		- 参数说明：

			- // 参数：length 表示要创建的ArrayBuffer的大小，单位为字节
			- // 返回值：ArrayBuffer对象
			- // 异常：如果length大于Number.MAX_SAFE_INTEGER （>= 2** 53）或者为负数，则跑出一个RangError异常

	- 【实例】

		- const buffer = new ArrayBuffer(32);

// console.log(buffer); // ArrayBuffer(32)

buffer.byteLength; // 32

const v = new Int32Array(buffer);

// console.log(v)  // Int32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]
// 32*8 / 32 8个元素

ArrayBuffer.isView(v); // true

const buffer2 = buffer.slice(0, 1);

// console.log(buffer2) // ArrayBuffer(1)

			- // 上面代码表示实例对象buffer占用32个字节
// 它有实例属性byteLength，表示当前实例占用的内存字节长度
// 它拥有一个静态方法isView()，这个方法可以用来判断是否为TypedArray实例或DataView实例
// 它拥有实例方法slice()，用来复制一部分内存，使用方式同数组的slice方法

// 除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写


	- 【特点】

		- ArrayBuffer 不能直接操作,而是要通过类型数组对象或 DataView 对象来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.
		- ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。

			- const buffer = new ArrayBuffer(8);
			- // ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）
			- console.log(buffer.byteLength);

		- 由于无法对 Arraybuffer 直接进行操作,所以我们需要借助其他对象来操作. 所有就有了 TypedArray(类型数组对象)和 DataView对象。

	- 【应用图解】

		- 

			- 先来介绍ArrayBuffer ,是因为 FileReader 有个 readAsArrayBuffer()的方法,如果被读的文件是二进制数据,那用这个方法去读应该是最合适的,读出来的数据,就是一个 Arraybuffer 对象

- 视图一：DataView 对象

	- 【介绍】

		- 上面代码生成了一段 8 字节的内存区域，每个字节的值默认都是 0。
		- 为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。

	- 【定义】

		- 【DataView】 视图是一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口。使用它时，不用考虑不同平台的字节序问题。

			- setint8() 从DataView起始位置以byte为计数的指定偏移量（byteOffset）处存储一个8-bit数（一个字节）
			- getint8() 从DataView起始位置以byte为计数的指定偏移量（byteOffset）处获取一个8-bit数（一个字节）
			- ❝
字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指存储器中或在数字通信链路中，组成多字节的字的字节的排列顺序。
字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。
例如假设上述变量 x 类型为int，位于地址 0x100 处，它的值为 0x01234567，地址范围为 0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。
❝

	- 【语法】

		- new DataView(buffer, [, byteOffset [, byteLength]])
		- 相关的参数说明如下：

			- buffer：ArrayBuffer 对象 或 SharedArrayBuffer 对象；
			- byteOffset（可选）：此 DataView 对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始；
			- 异常：此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度；

	- 【示例】

		- let buffer = new ArrayBuffer(2);
console.log(buffer.byteLength); // 2
let dataView = new DataView(buffer);
dataView.setInt8(0, 1);
dataView.setInt8(1, 2);
console.log(dataView.getInt8(0)); // 1
console.log(dataView.getInt8(1)); // 2
console.log(dataView.getInt16(0)); // 258

			- 例子2

				- const buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt8(1, 68);
view.getInt8(1); // 68

	- 【特殊情况】

		- 如果一次操作（get或者set）两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。
		- DataView的操作方法默认使用大端字节序解读数据，如果需要使用小端字节序解读，必须在操作方法中指定参数为true（get方法的第二个参数和set方法的第三个参数）。
		- 例子

			- const buffer = new ArrayBuffer(24);
const dv = new DataView(buffer);
// 1个字节，默认大端字节序
const v1 = dv.getUint8(0);
// 小端字节序
const v1 = dv.getUint16(1, true);
// 大端字节序
const v2 = dv.getUint16(3, false);
// 在第5个字节，以小端字节序写入值为11的32位整数
dv.setInt32(4, 11, true);

	- 对于直接处理ArrayBuffer对象的业务场景不是特别多，特别是写页面比较多的同学。笔者深刻认识并运用的场景，主要是在处理比较复杂且数据量比较大的点云数据，前端接收到的点云数据已经是原始采集数据转换过的二进制数据，前端需要对二进制数据进行解析，运用的解析方法就是上述提到的各种方法。下面介绍一下业务场景中比较常见到的一种二进制表示类型——Blob。

- 图示二：TypedArray

	- 【定义】

		- 另一种TypedArray视图，与DataView视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。
		- TypedArray对象描述了一个底层的二进制数据缓存区（binary data buffer）的一个类数组视图（view）。
		- TypedArray一共包含九种类型，每一种都是一个构造函数。（DataView视图不支持Uint8ClampedArray，其他都支持）

	- 【方法】

		- 常用的实现方法
		- 所有方法
		- 方法中的数字，是指的位数

	- 【静态属性】

		- 每一种视图都有一个BYTES_PER_ELEMENT常数，表示这种数据类型占据的字节数。

			- Int8Array.BYTES_PER_ELEMENT // 1
Uint8Array.BYTES_PER_ELEMENT // 1
Int16Array.BYTES_PER_ELEMENT // 2
Uint16Array.BYTES_PER_ELEMENT // 2
Int32Array.BYTES_PER_ELEMENT // 4
Uint32Array.BYTES_PER_ELEMENT // 4
Float32Array.BYTES_PER_ELEMENT // 4
Float64Array.BYTES_PER_ELEMENT // 8

	- 【例子】

		- const buffer = new ArrayBuffer(8);
console.log(buffer.byteLength); // 8
const int8Array = new Int8Array(buffer);
console.log(int8Array.length); // 8
const int16Array = new Int16Array(buffer);
console.log(int16Array.length); // 4

	- 【特点】

		- 这 9 个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，普通数组的操作方法和属性，对TypedArray 数组完全适用。

	- 【跟普通数组的差异】

		- 图示

	- 【转换】

		- TypedArray和Array之间也可以互相转换
		- 代码：

			- const typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.apply([], typedArray);

	- 「建立TypedArray视图」

		- // 创建一个8字节的ArrayBuffer
const a = new ArrayBuffer(8);

// 创建一个指向a的Int32视图，开始于字节0，直到缓冲区的末尾
const a1 = new Int32Array(a);

// 创建一个指向a的Uint8视图，开始于字节4，直到缓冲区的末尾， 为什么第二个参数的单位是字节，因为就是arraybuffer实例的描述单位
const a2 = new Uint8Array(a, 4);

// 创建一个指向a的Int16视图，开始于字节4，长度为2
const a3 = new Int16Array(a, 4, 2);
		- 上面代码在一段长度为 8 个字节的内存（a）之上，生成了三个视图：a1、a2和a3。

	- 【参数】

		- 视图的构造函数可以接受三个参数：

			- 第一个参数（必选）：视图对应的底层ArrayBuffer对象；
			- 第二个参数：视图开始的字节序号，默认从 0 开始；
			- 第三个参数：视图包含的数据个数，默认直到本段内存区域结束；

		- 建立了视图以后，就可以进行各种操作了
		- 这里需要明确的是，视图其实就是普通数组，语法完全没有什么不同，只不过它直接针对内存进行操作，而且每个成员都有确定的数据类型。所以，视图就被叫做“类型化数组”。

	- 「TypedArray视图操作」

		- 上面代码生成一个8字节的ArrayBuffer对象，然后在它的基础上，建立了一个16位整数的视图。

			- const buffer = new ArrayBuffer(8);
 
const int16View = new Int16Array(buffer);
 
for (let i = 0; i < int16View.length; i++) {
  int16View[i] = i * 2;
}
console.log(int16View) // [0, 2, 4, 6]
			- 由于每个字节占据8位，那么16位就占据了2个字节（1个字节等于8位），所以一共可以写入4个整数，依次为0，2，4，6。

		- 如果在这段数据上接着建立一个8位整数的视图，则可以读出完全不一样的结果。

			- const int8View = new Int8Array(buffer);
 
for (let i = 0; i < int8View.length; i++) {
  int8View[i] = i;
}

console.log(int8View) // [0, 0, 2, 0, 4, 0, 6, 0]
			- 首先整个ArrayBuffer对象会被分成8段。然后，由于x86体系的计算机都采用小端字节序（具体概念理解请自主查询），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。还可以看到下面这个例子

		- 例子

			- const buffer = new ArrayBuffer(4);
const v1 = new Uint8Array(buffer);
v1[0] = 10;
v1[1] = 3;
v1[2] = 11;
v1[3] = 8;

console.log(v1) // [10, 3, 11, 8]

const uInt16View = new Uint16Array(buffer); // [0xa, 0x3, 0xb, 0x8]

console.log(uInt16View) // 计算机采用小端字节序 [0x030a, 0x080b] => [778, 2059]
			- **如果一段数据是大端字节序（大端字节序主要用于数据传输），TypedArray 数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript 引入DataView对象，可以设定字节序。**

### FormData

- 家臣之FormData对象
- XMLHttpRequest Level 2添加了一个新的接口FormData. 利用FormData对象，我们可以通过JavaScript用一些键值对来模拟一系列表单控件，我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”表单”。比起普通的ajax, 使用FormData的最大优点就是我们可以异步上传一个二进制文件。
- 以上为官方口吻的解释，略抽象。我们应该都用过jQuery，其中有个方法叫做serialize(), 作用就是表单序列化，也就是以查询字符串形式获得类表单post/get的数据给Ajax请求，例如：userid=123&username=zxx.
- FormData对象的作用就类似于这里的serialize()方法，不过FormData是浏览器原生的，且支持二进制文件，是个一眼就会让人喜欢的很赞的东西！
- IE10+浏览器已经良好支持了，下面要介绍的其他家臣也都是IE10+支持。
- 实际使用是作为构造函数，如下：
- new FormData ([可选]HTMLFormElement)
- HTMLFormElement这个参数可选，可有可无。表示form表单元素，就是我们要序列化，要提交的那个表单元素。
- 例如：
- var newFormData = new FormData(someFormElement);
- newFormData就是someFormElement这个表单元素中所有键值对数据了。
- FormData提交格式的每个数据分三部分：

	- 第一部分也就是第一行，表示“分界线(boundary)”，我尚未深入研究这个分界线，不过，我没估计错的话，二进制大文件分隔传输时候，就是使用这个分界线。在webkit核心中，使用“——WebKitFormBoundary”加16位随机Base64位编码的字符串作为分隔边界。根据Firebug的显示，Firefox中，似乎是使用很多个"-"加时间戳进行边界分隔的。这里的边界的作用比较单纯，可能就是把表单的这两个字段作为两个独立数据流传输。
	- 第二部分也就是第二行，表示内容配置，这里都是统一的form-data（因为是FormData对象格式提交的），然后紧跟着name键值。
	- 第三部分就是第三行，表示传输的值。
	- FormData对象还有一个方法，为append()方法，可以人为的给当前FormData对象添加一个键/值对。

### Blob

- 【基本介绍】

	- Blob 对象比较常用于文件上传、文件读写操作等。
	- 在对文件读写的时候，我们更多的时候只是操作File对象，而File继承了所有Blob的属性。
	- Blob是用来支持文件操作的。简单的说：在JS中，有两个构造函数 File 和 Blob, 而File继承了所有Blob的属性。
	- 所以在我们看来，File对象可以看作一种特殊的Blob对象。
	- 而Blob 对象与 ArrayBuffer 的区别在于，Blob 对象用于操作二进制文件， ArrayBuffer 用于直接操作内存

		- Blob对象跟ArrayBuffer关系

			- 图示

- 【语法】

	- const blob = new Blob(array [, options]);

- 【参数】

	- array：字符串或二进制对象，表示新生成的Blob实例对象的内容；
	- options（可选）：比较常用的属性 type，表示数据的 MIME 类型，默认空字符串；

- 【示例】

	- const array = ['<h1>Hello World!</h1>'];
const blob = new Blob(array, {type : 'text/html'});

- 【属性和方法】

	- 图示
	- Blob对象拥有size和type两个属性，以及多种自有方法。
	- 比较常用的方法slice、arrayBuffer等；

		- slice方法主要用来拷贝原来的数据，返回的也是一个Blob实例，这个方法可以用来做切片上传。
		- arrayBuffer方法返回一个 Promise 对象，包含 blob 中的数据，并在 ArrayBuffer 中以二进制数据的形式呈现。

	- 代码

		- const blob = new Blob([]);
blob.slice(0, 1);
blob.arrayBuffer().then(buffer => /* 处理 ArrayBuffer 数据的代码……*/);

- 【Blob的应用】

	- 上面说了，File对象是一种特殊的Blob对象，那么它自然就可以直接调用Blob对象的方法。让我们看一看Blob具体有哪些方法，以及能够用它们实现哪些功能:

		- 

	- Blob URL

		- 通过window.URL.createObjectURL方法可以把一个blob转化为一个Blob URL，并且用做文件下载或者图片显示的链接。
		- Blob URL所实现的下载或者显示等功能，仅仅可以在单个浏览器内部进行。而不能在服务器上进行存储，亦或者说它没有在服务器端存储的意义。
		- 下面是一个Blob的例子，可以看到它很短

			- blob:d3958f5c-0777-0845-9dcf-2cb28783acaf

		- 和冗长的Base64格式的Data URL相比，Blob URL的长度显然不能够存储足够的信息，这也就意味着它只是类似于一个浏览器内部的“引用“。从这个角度看，Blob URL是一个浏览器自行制定的一个伪协议。

	- 【文件下载】

		- 后端提供或者返回Blob文件

			- 文件下载场景背景

				- 1. 文件下载地址在服务器上，a标签加上download属性，直接点击就可以下载了
				- 2. 文件是浏览器端js生成的内容或者后端返回blob格式给前端，浏览器进行下载

			- 后端返回Blob格式给前端

				- 前端请求blob的返回类型responseType类型

			- 前端自己生成的二进制文件，进行下载，这个例子好像忘记了revokeObjectURL

		- a标签下载

			- a标签及href指向的如果是一个下载链接，那么相当于下载文件，对于单文件下载还是ok的，不过快速点击几个下载按钮，有的下载会被Cancelled，这可不行
			- 

	- 【文件显示】

		- window.URL.createObjectURL生成的Blob URL还可以赋给img.src，从而实现图片的显示
		- 

	- 【Blob实现文件分片上传】

		- 通过Blob.slice(start,end)可以分割大Blob为多个小Blob
xhr.send是可以直接发送Blob对象的
		- 
		- 

	- 【本地读取文件内容】

		- 如果想要读取Blob或者文件对象并转化为其他格式的数据，可以借助FileReader对象的API进行操作

			- FileReader.readAsText(Blob)：将Blob转化为文本字符串
			- FileReader.readAsArrayBuffer(Blob)： 将Blob转为ArrayBuffer格式数据
			- FileReader.readAsDataURL(): 将Blob转化为Base64格式的Data URL
			- 下面我们尝试把一个文件的内容通过字符串的方式读取出来

		- 

	- 后端可能就是fs.readFileSync读取的二进制数据，前端通过设置resonseType进行切换，浏览器自动转化了类型

		- 

	- 【图片转为canvas】

		- 
		- [html2canvas截屏的场景](https://gitee.com/mirrors/html2canvas)

- 【Blob和ArrayBuffer互相转换】

	- ArrayBuffer转Blob

		- / / 1)var dataView = new DataView(arrayBuffer);

// var blob = new Blob([dataView], { type: mimeString });
		- arraybuffer转blob很方便，作为参数传入就行了

	- Blob转ArrayBuffer

		- // 2)fileReader.readAsArrayBuffer(blob);

// var arrayBuffer;

// fileReader.onload = function() {

//     arrayBuffer = this.result;

// };
		- 通过ArrayBuffer的格式读取本地数据
		- 通过ArrayBuffer的格式读取Ajax请求数据
通过xhr.responseType = “arraybuffer” 指定响应的数据类型，在onload回调里打印xhr.response

			- 
			- 

### XMLHttpRequest

- XMLHttpRequest带着两位家臣，DOMString和Document数据类型攻城略地，几乎一统天下。
- 为了顺应时代的潮流，XMLHttpRequest凹凸曼变身升级到2.0，变化诸多，其中一个很重要的变化就是广招家臣，扩张实力，与HTML5一起完成千秋万载之大业。
- 这些家臣有：DOMString、Document、FormData、Blob、File、ArrayBuffer这些类型。

### DOMString

- 家臣之DOMString
- 跟着XMLHttpRequest闯南走北很多年，看名字似乎很嚣张且高深莫测。实际上，在JavaScript中，DOMString就是String。规范解释说DOMString指的是UTF-16字符串，而JavaScript正是使用了这种编码的字符串，因此，在Ajax中，DOMString就等同于JS中的普通字符串。
- 大家应该都与XMLHttpRequest中数据返回属性之responseText打过交道吧，按照我的理解，这厮就是与DOMString数据类型发生关系的，表明返回的数据是常规字符串。

### 家臣之Document数据类型

- 如果单纯看Document对象，则解释很多，在这里，我们只要关注下图标注的这一个：
- responseXML
- 可以看到，实际上就是XMLHttpRequest中数据返回属性之responseXML，也就是可以解析为XML的数据。因此，这里的Document数据类似你就可以近似看成XML数据类型。
- DOMString和Document都是XMLHttpRequest时代就跟随的数据类型，元老级。下面这些数据类型都是XMLHttpRequest 2.0新增的，新招的家臣，各怀绝技哦！

### atob 和 btoa

- base64 相信大家都不会陌生吧（不知道的看这里）,最常用的操作可能就是图片转 base64 了吧?
- 在之前要在字符串跟base64之间互转,我们可能需要去网上拷一个别人的方法,而且大部分情况下,你没有时间去验证这个方法是不是真的可靠,有没有bug。
- 从IE10+浏览器开始，所有浏览器就原生提供了Base64编码解码方法。
- Base64 解码

	- var decodedData = window.atob(encodedData);

- Base64 编码

	- var encodedData = window.btoa(stringToEncode);

### Canvas中的ImageData对象

- [关于Canvas，这里我就不做过多介绍了，具体可参考canvas 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)

- 今天主要说一下Canvas中的ImageData对象（也是为下面的那个图片裁剪的项目做一些基础知识的铺垫～）
- ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：

	- width：图片宽度，单位是像素
	- height：图片高度，单位是像素
	- data：Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在 0 至 255 之间（包括 255）。

		- 8位无符号整型固定数组） 类型化数组表示一个由值固定在0-255区间的8位无符号整型组成的数组
		- 如果你指定一个在 [0,255] 区间外的值，它将被替换为0或255；如果你指定一个非整数，那么它将被设置为最接近它的整数。（数组）内容被初始化为0。一旦（数组）被创建，你可以使用对象的方法引用数组里的元素，或使用标准的数组索引语法（即使用方括号标记）。
		- 语法

			- new Uint8ClampedArray(length);
new Uint8ClampedArray(typedArray);
new Uint8ClampedArray(object);
new Uint8ClampedArray(buffer [, byteOffset [, length]]);

	- 创建一个ImageData对象

		- 使用createImageData() 方法去创建一个新的，空白的ImageData对象。
		- var myImageData = ctx.createImageData(width, height);
		- 上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。

	- 得到场景像素数据

		- 为了获得一个包含画布场景像素数据的ImageData对象，你可以用getImageData()方法：
		- var myImageData = ctx.getImageData(left, top, width, height);
		- [HTML canvas getImageData](https://www.w3school.com.cn/tags/canvas_getimagedata.asp)

		- 下面的代码通过 getImageData() 复制画布上指定矩形的像素数据，然后通过 putImageData() 将图像数据放回画布

	- 在场景中写入像素数据

		- 你可以用putImageData()方法去对场景进行像素数据的写入。
		- ctx.putImageData(myImageData, dx, dy);

	- toDataURL 将canvas转为 data URI格式

		- 有如下<canvas>元素：
		- <canvas id="canvas" width="5" height="5"></canvas>
		- 可以用下面的方式获取一个data-URL

			- var canvas = document.getElementById("canvas");
var dataURL = canvas.toDataURL();
console.log(dataURL);
// "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby
// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"

	- 像图片裁剪上传这种社区已经有非常成熟的解决方案了，如vue-cropper。

### [参考文档：理解DOMString、Document、FormData、Blob、File、ArrayBuffer数据类型](https://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/)

## 编码

### base64

- 原理

	- 「Base64」 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 「2⁶ = 64」 ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。
	- 相应的转换过程如下图所示：

- Base64 常用于在处理文本数据的场合

	- 表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。
	- 在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。
	- 使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。

- Base64 相应的索引表如下：

	- 图示

- 过程：编码 Man 为例，来直观的感受一下编码过程。Man 由 M、a 和 n 这 3 个字符组成，它们对应的 ASCII 码为 77、97 和 110。

	- M字母
	- 接着我们以每 6 个比特为一个单元，进行 base64 编码操作

- 如果要编码的字节数不能被 3 整除，最后会多出 1 个或 2 个字节，那么可以使用下面的方法进行处理：先使用 0 字节值在末尾补足，使其能够被 3 整除，然后再进行 base64 的编码。

	- 以编码字符 A 为例，其所占的字节数为 1，不能被 3 整除，需要补 2 个字节，具体如下图所示

- 在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串：

	- btoa()：该函数能够基于二进制数据 “字符串” 创建一个 base64 编码的 ASCII 字符串。
	- atob()： 该函数能够解码通过 base64 编码的字符串数据。

- btoa方法

	- Binary to ASCII，以base-64格式编码一串二进制数据

		- 编码
		- const base64 = window.btoa('abc'); // YWJj

	- binary string parse to base64 encode String

- atob方法

	- ASCII to Binary，给定一个base-64字符串，它返回二进制数据。

		- 解码
		- const initString = window.atob(base64); // abc

	- base64 encoded ascii to ucs-2 string

- 单字节-转换方式

	- 编码
	- const base64 = window.btoa('abc'); // YWJj
	- 解码
	- const initString = window.atob(base64); // abc

- 但是 btoa、atob 仅支持对 ASCII 字符编码，也就是单字节字符，而我们平时的中文都是 3-4 字节的字符。
- 因此可以先将中文字符转为 utf-8 的编码，将 utf-8 的编码当做字符，这样就可以对多个单字节字符进行编码。往下看。
- 多字节-转换方式

	- 编码（多字节）
	- const base64 = window.btoa(encodeURIComponent('春节')); // JUU2JTk4JUE1JUU4JThBJTgy
	- 解码（多字节）
	- const initString = decodeURIComponent(window.atob(base64)); // 春节
	- 另一种方式

		- // ucs-2 string to base64 encoded ascii
function utoa(str) {
    return window.btoa(unescape(encodeURIComponent(str)));
}

		- // base64 encoded ascii to ucs-2 string
function atou(str) {
    return decodeURIComponent(escape(window.atob(str)));
}
		- [地址](https://my.oschina.net/dreambreeze/blog/5079687)

- encodeURIComponent & decodeURIComponent

	- encodeURIComponent()

		- 用于执行将在URI中使用的字符串的URL编码。这将在URI中具有特殊含义的字符转换为%，然后是十六进制编码，例如，空格变成%20。这通常用于创建将在重定向或AJAX请求中使用的URL参数，或将在XMLHTTPRequest.send()中发送的数据。

	- decodeURIComponent()

		- decodeURIComponent()执行encodeURIComponent()的反转，所以如果您有"foo%20bar"它将返回"foo bar"。

	- 
	- 理解：感觉就是atob就是解码base64字符串，从6位二进制索引表对应字符序列，还原成8位二进制对应的字符序列

- [base64实现原理理解文章](https://chrunlee.cn/article/js-str-to-base64.html)

### 基础概念

- ASCII

	- 英文全称是American Standard Code for Information Interchange
	- 中文意思是美国信息交换标准代码，是基于拉丁字母的一套计算机编码系统，使用8位二进制表示字符。
	- 在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此8个二进制位就可以组合出256种状态，这被称为一个字节（byte）。
	- 换句话说，一个字节可以表示256种不同的状态，每一个状态对应一个符号，也就是256个符号，从0000 0000到1111 1111，其数量计算公式：2^{8} = 256。
	- 列举一部分ASCII码表，如图所示
	- 英语是由26个基本拉丁字母、阿拉伯数字和英式标点符号组成，因此用128个符号就足够l了，但ASCII码对于其他一些复杂的语言，就力不从心了，比如：汉字大约将近10万个（虽然没有准确的数字，但日常使用汉字也有几千字）。
	- 一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。为了正确显示中文字符，在1981年5月1日，由中国国家标准总局发布了《信息交换用汉字编码字符·基本集》，通常简称GB。

- GB类

	- GB2312

		- 中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。GB2312是简体中文常见的编码方式，使用两个字节表示一个汉字，所以最多可以表示2^{8} \times 2^{8} = 65536个符号。
		- GB2312标准共收录6763个汉字，其中一级汉字（常用字）3755个，二级汉字（较不常用）3008个，同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。
		- GB2312基本满足了计算机处理简体汉字的需求，所收录的汉字覆盖了99.75%的使用频率，但对于罕见字和繁体字，GB2312就不能处理了。因此发明了后来的GBK和GB18030。
		- GB2312，GBK和GB18030之间的关系如图所示

	- GBK

		- GBK编码是GB2312编码的超集，向下完全兼容GB2312，兼容的含义是不仅字符兼容，而且相同字符的编码也相同。

	- GB18030

		- 而GB18030编码向下兼容GBK和GB2312，GB18030编码是变长编码。

	- 缺点

		- 但很多像GB类的编码方式都有一个共同的问题，允许计算机处理双语环境，即拉丁字母和本地语言，却无法同时支持多语言环境，即多种语言混合的情况。Unicode就是为了解决这个问题而诞生的方案。

- Unicode

	- 背景

		- 世界上存在着多种语言，比如：西班牙语、韩语、俄语等等，它们也都分别有各自的编码方式，所以同一个二进制数字可以被解释成不同的符号。如果想要正确的打开一个文本文件，就必须知道它的编码方式，否则就会出现乱码。

	- 目标

		- 假如有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，一种所有符号的编码。

	- Unicode伴随着通用字符集的标准而发展，当前最新的版本为2019年5月公布的12.1.0，已经收录超过13万个字符。Unicode涵盖的数据除了视觉上的字形、编码方式、标准的字符编码外，还包含了字符特性，如大小写字母。
	- 然而，Unicode只是一个符号集，不代表计算机里的编码，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
	- 问题：

		- 计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？
		- 英文字母只用一个字节表示就够了，但按照Unicode规定，每个符号要用3个或4个字节表示，那么英语文本的存储空间将扩大3到4倍，是极大的浪费。

	- UTF-8

		- 随着互联网的发展，不同国家的信息越来越多地在网络中传播，强烈需要一种统一的编码方式，UTF-8就是在互联网上被广泛使用的一种Unicode实现方式。
		- 再次强调一下，UTF-8是Unicode的实现方式之一，并不是唯一，也不等同于Unicode。除了UTF-8，还有UTF-16和UTF-32，只是很少被使用。
		- UTF-8的特点是对不同范围的字符使用不同长度的编码，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
		- 编码规则：

			- 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
			- 对于n字节的符号（n>1)，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的Unicode码。
			- 
			- 例子

				- 以“爱”为例，其二进制为01110010 00110001，其的Unicode是U+7231，是在U+0800～U+FFFF范围内，所以采用3个字节进行编码。

### 字符编码

- charCodeAt

	- "𠮷".charCodeAt(0).toString(16) //d842
	- "𠮷".charCodeAt(1).toString(16) //dfb7
	- "\ud842\udfb7" //"𠮷"
	- 使用charCodeAt()您需要检索第一个和第二个，并将它们合并。

- codePointAt

	- JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。
	- "𠮷".codePointAt(0) //20bb7
	- "\u{20bb7}" //"𠮷"
	- ES2015中引入了此功能，以处理无法由单个16位Unicode单元表示但需要2个字符的Unicode字符。

- unescape() 函数可对通过 escape() 编码的字符串进行解码。
- escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。

	- 并没有说明是如何编码的，啥时候应该使用？

- 字符串字符数大小vs编码单元的大小

	- [关于 JavaScript 字符串的一个小知识](https://juejin.cn/post/6860651188090585101)

- URI编解码

	- 预备知识：URI
	- 原因？

		- 通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如Size过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为Url中有些字符会引起歧义。
		- 例如Url参数字符串中使用key=value键值对这样的形式来传参，键值对之间以&符号分隔，如/s?q=abc& ie=utf-8。如果你的value字符串中包含了=或者&，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&和= 符号进行转义，也就是对其进行编码。
		- 又如，Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如中文。否则如果客户端浏览器和服务端浏览器支持的字符集不同的情况下，中文可能会造成问题。
		- Url编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。

	- 如何做？
	- [文章：为什么要进行URI编解码、怎么做？](https://blog.csdn.net/wxs0124/article/details/79098077)

	- [文章：URI编码解码和base64](https://www.cnblogs.com/accordion/p/4178289.html)

- base64编码

	- window.btoa()

		- 该函数无法针对宽字节进行base64编码，若针对中文编码，则需现转换为 UTF-8 编码，然后进行 base64 编码。
		- function unicodeToBase64(s){
　　　　return window.btoa(unescape(encodeURIComponent(s)))
　　}

- [文章：前端开发中的字符编码](https://segmentfault.com/a/1190000005078371)

- [文章：URI编码解码和base64](https://www.cnblogs.com/accordion/p/4178289.html)

- [文章：HTML 实体编码与进制编码](https://segmentfault.com/a/1190000005078371)

	- 主要提醒大家在预防 XSS 时需要注意的几点：

		- 检测用户输入时，不仅仅需要防范类似 <> 这样的字符，通过 unicode 编码或进制编码仍有可能注入代码
		- 需要针对特定的关键字做过滤，如 eval、write、prototype
		- 尽可能禁止内联事件处理函数的使用
		- js 过滤 src/href/action 属性，如 javascript:, data:

## 图片处理

### 图示1

### 图示2

## DOMParser和XMLSerializer两个API简介

### [地址](https://www.zhangxinxu.com/wordpress/2019/06/domparser-xmlserializer-api/)

### 语法

- var domParser = new DOMParser();​​​​​​

### 该方法语法如下：

- var doc = domParser.parseFromString(string, mimeType);​​​​​​

### 例子

- var domParser = new DOMParser();
- console.dir(domParser.parseFromString('<p>内容</p>', 'text/html'));

### 兼容性

- DOMParser方法IE9+均支持。

### XMLSerializer

- XMLSerializer方法的作用和DOMParser相反，XMLSerializer可以让DOM树对象序列化为字符串。
- 语法

	- var xmlSerializer = new XMLSerializer();

## 自由主题

