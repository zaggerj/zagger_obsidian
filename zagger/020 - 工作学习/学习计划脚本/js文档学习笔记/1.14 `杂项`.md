---
created: 2023-11-03T22:29
updated: 2023-11-03T22:29
---
  * [ ] 1.14 `杂项`
    * [ ] 1.14.1 `Proxy 和 Reflect` (2023/10/20)[点击](https://zh.javascript.info/proxy)
    * [ ] 1.14.2 `Eval：执行代码字符串` (2023/10/20)[点击](https://zh.javascript.info/eval)
    * [ ] 1.14.3 `柯里化（Currying）` (2023/10/20)[点击](https://zh.javascript.info/currying-partials)
    * [ ] 1.14.4 `Reference Type` (2023/10/23)[点击](https://zh.javascript.info/reference-type)
    * [ ] 1.14.5 `BigInt` (2023/10/23)[点击](https://zh.javascript.info/bigint)
    * [ ] 1.14.6 `Unicode —— 字符串内幕` (2023/10/23)[点击](https://zh.javascript.info/unicode)

# 1. Proxy 和 Reflect

一个 `Proxy` 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。

Proxy 被用于了许多库和某些浏览器框架。在本文中，我们将看到许多实际应用。

## 1.1. [Proxy](https://zh.javascript.info/proxy#proxy)

语法：

```js
let proxy = new Proxy(target, handler)
```

- `target` —— 是要包装的对象，可以是任何东西，包括函数。
- `handler` —— 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象。比如 `get` 捕捉器用于读取 `target` 的属性，`set` 捕捉器用于写入 `target` 的属性，等等。

对 `proxy` 进行操作，如果在 `handler` 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。

首先，让我们创建一个没有任何捕捉器的代理（Proxy）：